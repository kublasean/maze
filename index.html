<hmtl>
  <head>
    <title>maze</title>
    <script src="arcball.js"></script>
    <script src="dset.js"></script>
    <script src="maze.js"></script>
    <script src="walls.js"></script>
    <script src="util/sylvester.js"></script>
    <script src="util/gl_util.js"></script>
    <script src="util/gl_transforms.js"></script>
    <script src="util/shaders.js"></script>
    <script src="util/model.js"></script>
    <script src="util/math.js"></script>
    <script src="util/events.js"></script>
    <script src="camera.js"></script>
    <script src="player.js"></script>
    <script src="gl_main.js"></script>
    <style>
    body, html {
      margin: 0;
      padding: 0;
      border: 0;
      width: 100%;
      height: 100%;
      background-color: grey;
      overflow: hidden;
    }

    form {

    }
      canvas {
        width: 100%;
        height: 100%;
        background-color: white;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas">canvas not supported</canvas>
    <script id="FragmentShader_BUN" type="x-shader/x-fragment">
     #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;
    varying vec3 interpL;
    varying vec3 interpV;
    varying vec3 interpN;
    uniform vec3 u_color;

    vec3 K_a = vec3(0.1745, 0.01175, 0.01175);
		//vec3 K_d = vec3(0.61424, 0.04136, 0.04136);
		vec3 K_s = vec3(0.727811, 0.626959, 0.626959);
    float n = 0.6;

    void main(void){
      vec3 L = normalize(interpL);
      vec3 V = normalize(interpV);
      vec3 N = normalize(interpN);
      vec3 R = normalize(2.0*clamp(dot(N,L), 0.0, 1.0)*N-L);
      vec3 K_d = u_color;

      vec3 vColor = K_a + K_d*clamp(dot(N,L),0.0, 1.0) + K_s*pow(clamp(dot(R,V),0.0, 1.0),n);
      gl_FragColor = vec4(vColor, 1.0);
    }

</script>
<script id="VertexShader_BUN" type="x-shader/x-vertex">

		attribute vec3 a_position;
		attribute vec3 a_normal;

    uniform mat4 u_model;
    uniform mat4 u_camera;
    uniform mat4 u_view;
    uniform mat4 u_projection;
		uniform vec3 u_lightPos;

    varying vec3 interpL;
    varying vec3 interpV;
    varying vec3 interpN;

    void main(void) {
        gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
        vec3 vert = (u_view * u_model * vec4(a_position,1.0)).xyz;

        interpL = u_lightPos - vert;
				//interpL = vert - u_lightPos;
        interpV = -vert;
        interpN = vec3(u_view * u_model * vec4(a_normal, 0.0));
    }
</script>
<script id="FragmentShader_WALL" type="x-shader/x-fragment">
 #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
#endif

precision mediump float;
varying vec3 interpL;
varying vec3 interpV;
varying vec3 interpN;
varying float v_worldy;

uniform vec3 u_color;
uniform float u_type; //1=side 0=flat
uniform float u_playerPos;

vec3 K_a = vec3(0.01745, 0.01175, 0.01175);
vec3 K_s = vec3(0.0, 0.0, 0.0);
float n = 0.6; 

void main(void){
  vec3 L = normalize(interpL);
  vec3 V = normalize(interpV);
  vec3 N = normalize(interpN);
  vec3 R = normalize(2.0*clamp(dot(N,L), 0.0, 1.0)*N-L);
  vec3 K_d = u_color;

  vec3 vColor = K_a + K_d*clamp(dot(N,L),0.0, 1.0) + K_s*pow(clamp(dot(R,V),0.0, 1.0),n);
  
	//if (u_type == 1.0 && v_worldy+3.1 < u_playerPos) {
    //discard;
	//}
	//if (u_type != 1.0 && v_worldy+3.1 < u_playerPos) {
	//	discard;
	//}
	//float alpha = clamp(u_playerPos - v_worldy+2.76, 0.0, 1.0);
	float alpha = 1.0;
  gl_FragColor = vec4(vColor, alpha);
}

</script>
<script id="VertexShader_WALL" type="x-shader/x-vertex">

attribute vec3 a_position;
attribute vec3 a_normal;

precision mediump float;
uniform mat4 u_model;
uniform mat4 u_camera;
uniform mat4 u_view;
uniform mat4 u_projection;
uniform vec3 u_lightPos;
uniform vec3 u_color;
uniform float u_playerPos;

varying vec3 interpL;
varying vec3 interpV;
varying vec3 interpN;
varying float v_worldy;

void main(void) {
    gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);

    vec3 vert = (u_view * u_model * vec4(a_position,1.0)).xyz;
    vec3 world = (u_model * vec4(a_position,1.0)).xyz;
    interpL = u_lightPos - vert;
    //interpL = vert - u_lightPos;
    interpV = -vert;
    interpN = vec3(u_view * u_model * vec4(a_normal, 0.0));
		
    v_worldy = world.y;
}
</script>
<script>
    var gl=null;
    
    //set up webgl context
    function setup() {
        var canvas = document.getElementById("glcanvas");
        gl = canvas.getContext("webgl");
        if (!gl)
            return;
        newRound(3);
    }
    setup();
</script>
</body>
</html>
