function Shader(vert, frag) {
    this.program = createProgramFromScripts(vert, frag);
    this.uniformSetters = createUniformSetters(this.program);
    this.attribSetters = createAttributeSetters(this.program);
}

function createUniformSetters(program) {
    var textureUnit = 0;

    function createUniformSetter(program, uniformInfo) {
        var location = gl.getUniformLocation(program, uniformInfo.name);
        var type = uniformInfo.type;
        // Check if this uniform is an array
        var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
        if (type === gl.FLOAT && isArray) {
            return function(v) {
            gl.uniform1fv(location, v);
            };
        }
        if (type === gl.FLOAT) {
            return function(v) {
            gl.uniform1f(location, v);
            };
        }
        if (type === gl.FLOAT_VEC2) {
            return function(v) {
            gl.uniform2fv(location, v);
            };
        }
        if (type === gl.FLOAT_VEC3) {
            return function(v) {
            gl.uniform3fv(location, v);
            };
        }
        if (type === gl.FLOAT_VEC4) {
            return function(v) {
            gl.uniform4fv(location, v);
            };
        }
        if (type === gl.INT && isArray) {
            return function(v) {
            gl.uniform1iv(location, v);
            };
        }
        if (type === gl.INT) {
            return function(v) {
            gl.uniform1i(location, v);
            };
        }
        if (type === gl.INT_VEC2) {
            return function(v) {
            gl.uniform2iv(location, v);
            };
        }
        if (type === gl.INT_VEC3) {
            return function(v) {
            gl.uniform3iv(location, v);
            };
        }
        if (type === gl.INT_VEC4) {
            return function(v) {
            gl.uniform4iv(location, v);
            };
        }
        if (type === gl.BOOL) {
            return function(v) {
            gl.uniform1iv(location, v);
            };
        }
        if (type === gl.BOOL_VEC2) {
            return function(v) {
            gl.uniform2iv(location, v);
            };
        }
        if (type === gl.BOOL_VEC3) {
            return function(v) {
            gl.uniform3iv(location, v);
            };
        }
        if (type === gl.BOOL_VEC4) {
            return function(v) {
            gl.uniform4iv(location, v);
            };
        }
        if (type === gl.FLOAT_MAT2) {
            return function(v) {
            gl.uniformMatrix2fv(location, false, v);
            };
        }
        if (type === gl.FLOAT_MAT3) {
            return function(v) {
            gl.uniformMatrix3fv(location, false, v);
            };
        }
        if (type === gl.FLOAT_MAT4) {
            return function(v) {
            gl.uniformMatrix4fv(location, false, v);
            };
        }
        if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {
            var units = [];
            for (var ii = 0; ii < info.size; ++ii) {
            units.push(textureUnit++);
            }
            return function(bindPoint, units) {
            return function(textures) {
                gl.uniform1iv(location, units);
                textures.forEach(function(texture, index) {
                gl.activeTexture(gl.TEXTURE0 + units[index]);
                gl.bindTexture(bindPoint, texture);
                });
            };
            }(getBindPointForSamplerType(gl, type), units);
        }
        if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {
            return function(bindPoint, unit) {
            return function(texture) {
                gl.uniform1i(location, unit);
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(bindPoint, texture);
            };
            }(getBindPointForSamplerType(gl, type), textureUnit++);
        }
        throw ("unknown type: 0x" + type.toString(16)); // we should never get here.
    }

    var uniformSetters = { };
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var ii = 0; ii < numUniforms; ++ii) {
    var uniformInfo = gl.getActiveUniform(program, ii);
    if (!uniformInfo) {
        break;
    }
    var name = uniformInfo.name;
    // remove the array suffix.
    if (name.substr(-3) === "[0]") {
        name = name.substr(0, name.length - 3);
    }
    var setter = createUniformSetter(program, uniformInfo);
    uniformSetters[name] = setter;
    }
    return uniformSetters;
}

/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     var programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     var tex1 = gl.createTexture();
 *     var tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     var uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     setUniforms(programInfo.uniformSetters, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     var uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     var moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     setUniforms(programInfo.uniformSetters, uniforms);
 *     setUniforms(programInfo.uniformSetters, moreUniforms);
 *
 * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from
 *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.
 * @param {Object.<string, value>} an object with values for the
 *        uniforms.
 * @memberOf module:webgl-utils
 */
function setUniforms(setters, values) {
    setters = setters.uniformSetters || setters;
    Object.keys(values).forEach(function(name) {
        var setter = setters[name];
        if (setter) {
            setter(values[name]);
        }
    });
}

function createAttributeSetters(program) {
    var attribSetters = {};

    function createAttribSetter(index) {
        return function(b) {
            gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
            gl.enableVertexAttribArray(index);
            gl.vertexAttribPointer(
                index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);
        };
    }

    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var ii = 0; ii < numAttribs; ++ii) {
        var attribInfo = gl.getActiveAttrib(program, ii);
        if (!attribInfo) {
            break;
        }
        var index = gl.getAttribLocation(program, attribInfo.name);
        attribSetters[attribInfo.name] = createAttribSetter(index);
    }
    return attribSetters;
}

/**
 * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})
 *
 * Example:
 *
 *     var program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     var attribSetters = createAttributeSetters(program);
 *
 *     var positionBuffer = gl.createBuffer();
 *     var texcoordBuffer = gl.createBuffer();
 *
 *     var attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     var attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}
 * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @memberOf module:webgl-utils
 * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}
 */
function setAttributes(setters, attribs) {
    setters = setters.attribSetters || setters;
    Object.keys(attribs).forEach(function(name) {
        var setter = setters[name];
        if (setter) {
            setter(attribs[name]);
        }
    });
}